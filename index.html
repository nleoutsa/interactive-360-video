<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8">
        <title>Hapyak A-Frame Example</title>
        <script src="vendor/aframe-0.1.3.js"></script>
        <script src="vendor/jquery-2.2.2.js"></script>
        <script src="vendor/html2canvas.js"></script>
        <script src="vendor/projector.js"></script> <!-- include projector.js since it's been removed from THREE. There should be a newer way to accomplish this -->
        <script src="vendor/canvasRenderer.js"></script> <!-- include canvasRenderer.js since it's been removed from THREE. There should be a newer way to accomplish this -->

        <style type="text/css">
            .textAnnotation {
                position: absolute;
                color: #fff;
                background-color: #db6327;
                border: 5px solid #333;
                text-align: center;
                font-size: 18px;
                padding: 10px;
                width: 100px;
                height: 50px;
                z-index: 99;
            }
            #annotationsContainer {
                /*position: absolute;*/
                /*z-index: 99;*/
                transform-style: preserve-3d;
                transform: translateX(50vw) translateY(50vh);
            }
        </style>
    </head>
    <body>

        <div id="aSceneContainer"></div>

        <div id="annotationsContainer"></div>

        <script type="text/javascript">
            var WIDTH = window.innerWidth;
            var HEIGHT = window.innerHeight;

            var projector = new THREE.Projector();

            var aSceneContainer = document.getElementById('aSceneContainer');
            var annotationsContainer = document.getElementById('annotationsContainer');

            var annotationList = []; // will come from hapyak annotation list
            var annotation3DObjects = [];

            var aScene,
                aMark,
                cameraElement,
                raycaster,
                mouse,
                renderer;

            function getAnnotations () {
                // for now, create fake pop annotation
                var annotationWrapper = document.createElement('div');
                var popAnnotation = document.createElement('div');
                annotationWrapper.appendChild(popAnnotation);
                var popLink = document.createElement('a');
                popLink.setAttribute('href', 'http://www.hapyak.com')
                popLink.innerHTML = "HapYak";
                popAnnotation.appendChild(popLink);
                annotationWrapper.className = "textAnnotation";
                annotationWrapper.id = "textAnnotation";
                annotationList.push(annotationWrapper);
            }

            function updateAnnotations (cycles) {
                window.requestAnimationFrame(function () {
                    positionAnnotation(aMark);

                    updateAnnotations(cycles + 1);
                });
            }

            function positionAnnotation(placeholder) {
                var coords = get2DCoordinates(placeholder);

                camRotX = cameraElement.components.rotation.data.x;
                camRotY = cameraElement.components.rotation.data.y;

                annotationsContainer.style.transform = 'translateZ(' + 100 + 'px) translateX(' + coords.x + 'px) translateY(' + coords.y + 'px) rotateY(' + camRotY + 'deg)';
            }

            function setupRaycaster() {

                raycaster = new THREE.Raycaster();
                mouse = new THREE.Vector2();

                renderer = new THREE.CanvasRenderer();
                renderer.setClearColor( 0xf0f0f0 );
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( window.innerWidth, window.innerHeight );
                annotationsContainer.appendChild( renderer.domElement );

                addAnnotationObjectsForRaycasting();

                // stats = new Stats();
                // stats.domElement.style.position = 'absolute';
                // stats.domElement.style.top = '0px';
                // annotationsContainer.appendChild( stats.domElement );

                document.addEventListener('mousedown', onDocumentMouseDown, false);
                document.addEventListener('touchstart', onDocumentTouchStart, false);
            }
            function onDocumentTouchStart( event ) {

                event.preventDefault();

                event.clientX = event.touches[0].clientX;
                event.clientY = event.touches[0].clientY;
                onDocumentMouseDown(event);
            }

            function onDocumentMouseDown( event ) {
                event.preventDefault();

                mouse.x = (event.clientX / renderer.domElement.clientWidth) * 2 - 1;
                mouse.y = -(event.clientY / renderer.domElement.clientHeight) * 2 + 1;

                raycaster.setFromCamera(mouse, cameraElement.object3D.children[0]);
                console.log(annotation3DObjects);
                var intersects = raycaster.intersectObjects(annotation3DObjects);

                if (intersects.length > 0) {
                    console.log('intersects');
                    // intersects[0].object.material.color.setHex(Math.random() * 0xffffff);

                    // var particle = new THREE.Sprite(particleMaterial);
                    // particle.position.copy(intersects[0].point);
                    // particle.scale.x = particle.scale.y = 16;
                    // scene.add(particle);
                }
            }

            function addAnnotationsToScene() {
                getAnnotations();
                for (index in annotationList) {
                    aScene.appendChild(createAFramePlaceholder(annotationList[index]));
                }
            }

            function addAnnotationObjectsForRaycasting() {
                for (index in annotationList) {
                    var annotation3DObject = createAFramePlaceholder(annotationList[index]);
                    annotation3DObjects.push(annotation3DObject.object3D);
                }
            }

            function createAFramePlaceholder (annotation) {
                annotationsContainer.appendChild(annotation);

                var aImage = document.createElement('a-image');
                aImage.setAttribute('id', annotation.id);
                aImage.setAttribute('look-at', '[camera]');
                aImage.setAttribute('position', '0 0 -7');

                html2canvas(annotation, {
                    onrendered: function(canvas) {
                        var imageUrl = canvas.toDataURL("image/png");

                        aImage.setAttribute('src', imageUrl);
                        aImage.setAttribute('width', canvas.width / 100);
                        aImage.setAttribute('height', canvas.height / 100);
                    }
                });

                // aImage.addEventListener('click', function () {
                //     this.setAttribute('height', Math.random(this.height));
                //     this.setAttribute('width', Math.random(this.width));
                //     console.log('I was clicked!');
                // });

                return aImage;
            }

            function get2DCoordinates(placeholder) {

                var coords = {};

                var position3D,
                    vector2D,
                    percentX,
                    percentY;

                var vector = new THREE.Vector3();
                // Get webgl object's position relative to world
                // position3D = placeholder.object3D.matrixWorld.getPosition().clone();
                vector.setFromMatrixPosition(placeholder.object3D.matrixWorld);

                // // use 'project' to translate position to 2D view that the perspective camera renders
                vector2D = vector.project(cameraElement.object3D.children[0]);

                // translate vector so that
                // vector2D.x & vector2D.y have range [-1, 1].
                // add 1 to them and divide by 2 so 0 represents left & top edges
                // and 1 represents right & bottom edges
                // then multiply by screen width or height to get pixel value
                coords.x = ((vector2D.x + 1) / 2) * WIDTH;
                coords.y = ((-vector2D.y + 1) / 2) * HEIGHT;

                return coords;
            }

            function createAFrame360Scene() {
                aScene = document.createElement('a-scene');

                var aCameraContainer = document.createElement('a-entity');
                aCameraContainer.setAttribute('position', '0 0 0');
                aCameraContainer.innerHTML = "" +
                    "<a-entity camera look-controls id='main-camera'>" +
                        // "<a-entity " +
                        //     "cursor='maxDistance: 30; timeout: 500' " +
                        //     "position='0 0 -27' " +
                        //     "geometry='primitive: ring' " +
                        //     "material='color: red; shader: flat'>" +
                        // "</a-entity>" +
                    "</a-entity>";

                aScene.appendChild(aCameraContainer);

                // aMark = document.createElement('a-plane');
                // aMark.setAttribute('id', 'aMark');
                // aMark.setAttribute('position', '0 0 -7');
                // aMark.setAttribute('look-at', '[camera]');
                // aScene.appendChild(aMark);

                var aVideosphere = document.createElement('a-videosphere');
                aVideosphere.setAttribute('src', 'videos/car.mp4');
                aVideosphere.setAttribute('autoplay', 'true');
                aScene.appendChild(aVideosphere);

                addAnnotationsToScene();

                aSceneContainer.appendChild(aScene);
            }

            createAFrame360Scene();

            window.addEventListener("loaded", function (e, t) {
                cameraElement = document.getElementById('main-camera');

                setupRaycaster();

                // updateAnnotations(0);

            });

        </script>
    </body>
</html>
